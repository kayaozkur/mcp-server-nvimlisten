import { execa } from "execa";
import * as fs from "fs/promises";
import * as path from "path";
import * as os from "os";

export class KeybindingHandler {
  private configDir: string;

  constructor() {
    this.configDir = path.join(os.homedir(), ".config", "nvim");
  }

  async getKeybindings(args: any) {
    const { mode = "all", plugin, format = "json" } = args;

    try {
      // Get keybindings from Neovim
      const modeFilter = mode === "all" ? "" : `mode = '${mode.charAt(0)}'`;
      const pluginFilter = plugin ? `and desc:match('${plugin}')` : "";
      
      const luaCommand = `
        local bindings = {}
        local modes = ${mode === "all" ? "{'n', 'i', 'v', 'x', 'c', 't'}" : `{'${mode.charAt(0)}'}`}
        
        for _, m in ipairs(modes) do
          local maps = vim.api.nvim_get_keymap(m)
          for _, map in ipairs(maps) do
            ${pluginFilter ? `if map.desc and map.desc:match('${plugin}') then` : ''}
              table.insert(bindings, {
                mode = m,
                key = map.lhs,
                command = map.rhs or map.callback and '<function>' or '',
                description = map.desc or '',
                source = map.sid and 'plugin' or 'user'
              })
            ${pluginFilter ? 'end' : ''}
          end
        end
        
        print(vim.json.encode(bindings))
      `;

      const { stdout } = await execa("nvim", [
        "--headless",
        "-c",
        `lua ${luaCommand}`,
        "-c",
        "quit"
      ]);

      let result = stdout;

      // Format output based on requested format
      if (format === "markdown") {
        const bindings = JSON.parse(stdout);
        result = this.formatAsMarkdown(bindings);
      } else if (format === "table") {
        const bindings = JSON.parse(stdout);
        result = this.formatAsTable(bindings);
      }

      return {
        content: [
          {
            type: "text",
            text: result,
          },
        ],
      };
    } catch (error: any) {
      throw new Error(`Failed to get keybindings: ${error.message}`);
    }
  }

  async updateKeybindings(args: any) {
    const { keybindings, backup = true } = args;

    try {
      const mappingsPath = path.join(this.configDir, "lua", "mappings.lua");

      if (backup) {
        await this.createBackup(mappingsPath);
      }

      // Generate Lua code for keybindings
      let luaCode = "-- Keybindings generated by MCP server\n\n";
      luaCode += "local map = vim.keymap.set\n\n";

      for (const binding of keybindings) {
        const { mode, key, command, description, opts = {} } = binding;
        const optsStr = JSON.stringify({ ...opts, desc: description });
        luaCode += `map('${mode}', '${key}', '${command}', ${optsStr})\n`;
      }

      // Append to existing mappings or create new file
      try {
        const existing = await fs.readFile(mappingsPath, "utf-8");
        luaCode = existing + "\n\n" + luaCode;
      } catch {
        // File doesn't exist, use generated code
      }

      await fs.writeFile(mappingsPath, luaCode, "utf-8");

      return {
        content: [
          {
            type: "text",
            text: `Updated ${keybindings.length} keybindings in ${mappingsPath}`,
          },
        ],
      };
    } catch (error: any) {
      throw new Error(`Failed to update keybindings: ${error.message}`);
    }
  }

  private formatAsMarkdown(bindings: any[]): string {
    let md = "# Neovim Keybindings\n\n";
    
    const byMode = bindings.reduce((acc, b) => {
      if (!acc[b.mode]) acc[b.mode] = [];
      acc[b.mode].push(b);
      return acc;
    }, {} as Record<string, any[]>);

    const modeNames: Record<string, string> = {
      n: "Normal Mode",
      i: "Insert Mode",
      v: "Visual Mode",
      x: "Visual Block Mode",
      c: "Command Mode",
      t: "Terminal Mode"
    };

    for (const [mode, mappings] of Object.entries(byMode)) {
      md += `## ${modeNames[mode] || mode}\n\n`;
      md += "| Key | Command | Description |\n";
      md += "|-----|---------|-------------|\n";
      
      const typedMappings = mappings as any[];
      for (const map of typedMappings) {
        md += `| \`${map.key}\` | \`${map.command}\` | ${map.description} |\n`;
      }
      md += "\n";
    }

    return md;
  }

  private formatAsTable(bindings: any[]): string {
    let table = "Mode | Key       | Command                    | Description\n";
    table +=     "-----+-----------+----------------------------+------------------\n";
    
    for (const b of bindings) {
      const mode = b.mode.padEnd(4);
      const key = b.key.padEnd(9);
      const cmd = (b.command.substring(0, 26) + (b.command.length > 26 ? "..." : "")).padEnd(26);
      table += `${mode} | ${key} | ${cmd} | ${b.description}\n`;
    }

    return table;
  }

  private async createBackup(filePath: string): Promise<void> {
    try {
      const content = await fs.readFile(filePath, "utf-8");
      const backupPath = `${filePath}.backup.${Date.now()}`;
      await fs.writeFile(backupPath, content, "utf-8");
    } catch {
      // File might not exist
    }
  }
}